package JavaKaja.runtime;

/*Generated by MPS */

import javax.swing.JPanel;
import java.awt.GridLayout;
import java.util.List;
import java.util.ArrayList;
import javax.swing.JFrame;
import javax.swing.Icon;
import javax.swing.UIManager;
import javax.swing.plaf.metal.MetalLookAndFeel;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.ImageIcon;
import java.awt.Dimension;
import java.awt.BorderLayout;
import javax.swing.JOptionPane;
import java.awt.Color;
import javax.swing.SwingUtilities;
import java.awt.Font;

public abstract class KajaFrame {
  public static final int HEIGHT = 30;
  public static final int WIDTH = 45;
  private static final int CELL_SIZE = 3;
  protected final int width = CELL_SIZE * WIDTH;
  protected final int height = CELL_SIZE * HEIGHT;
  protected final JPanel canvas = new JPanel(new GridLayout(HEIGHT, WIDTH), true);
  protected final Cell[][] world = new Cell[HEIGHT][WIDTH];
  protected final VisualCell[][] visuals = new VisualCell[HEIGHT][WIDTH];
  private List<Vehicle> vehicles = new ArrayList<Vehicle>();
  private List<TrafficLightCell> trafficLights = new ArrayList<TrafficLightCell>();

  private final JFrame frame = new JFrame("Traffic Simulator");
  private Icon karelIconNorth;
  private Icon karelIconEast;
  private Icon karelIconSouth;
  private Icon karelIconWest;
  private boolean stopped = false;
  public KajaFrame() {
  }
  public final void initializeComponents() {
    try {
      UIManager.setLookAndFeel(new MetalLookAndFeel());
    } catch (UnsupportedLookAndFeelException e) {
      throw new RuntimeException(e);
    }
    ClassLoader classLoader = getClass().getClassLoader();
    karelIconNorth = new ImageIcon(classLoader.getResource("kaja/kajaNorth.png"));
    karelIconEast = new ImageIcon(classLoader.getResource("kaja/kajaEast.png"));
    karelIconSouth = new ImageIcon(classLoader.getResource("kaja/kajaSouth.png"));
    karelIconWest = new ImageIcon(classLoader.getResource("kaja/kajaWest.png"));

    for (int i = 0; i < HEIGHT; i++) {
      for (int j = 0; j < WIDTH; j++) {
        world[i][j] = new WallCell();
        VisualCell button = new VisualCell();
        button.setEnabled(false);
        visuals[i][j] = button;
        canvas.add(button);
      }
    }

    frame.setPreferredSize(new Dimension(width, height));
    frame.setResizable(true);
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.add(BorderLayout.CENTER, canvas);
    frame.setVisible(true);
    frame.pack();
    updateUI();
  }

  public final void run() {
    perform();
  }

  protected abstract void perform();

  public void reportError(String msg) {
    JOptionPane.showMessageDialog(canvas, msg, "Error", JOptionPane.ERROR_MESSAGE);
    stop();
  }

  public void trace(String msg) {
    JOptionPane.showMessageDialog(canvas, msg, "Trace", JOptionPane.INFORMATION_MESSAGE);
  }

  public void tick() {
    // For traffic light in traffic light. Tick traffic light 
    for (TrafficLightCell trafficLight : trafficLights) {
      trafficLight.tick();
    }

    for (Vehicle vehicle : vehicles) {
      if (!(vehicle.hasReachedDestination())) {
        moveVehicle(vehicle);
      }
    }

    for (Vehicle vehicle : vehicles) {
      vehicle.unsetTicked();
    }
    updateUI();
  }

  protected Cell getCurrentCell(Position position) {
    return world[position.getRow()][position.getCol()];
  }

  protected Cell getCurrentCell(int row, int col) {
    return world[row][col];
  }
  protected Cell getNextCell(Position position, Direction direction) {
    int row = position.getRow();
    int col = position.getCol();
    switch (direction) {
      case north:
        return world[row - 1][col];
      case east:
        return world[row][col + 1];
      case south:
        return world[row + 1][col];
      case west:
        return world[row][col - 1];
      default:
        return null;
    }
  }

  protected Position getNextPosition(Position position, Direction direction) {
    int row = position.getRow();
    int col = position.getCol();
    switch (direction) {
      case north:
        return position.setRow(row - 1);
      case east:
        return position.setCol(col + 1);
      case south:
        return position.setRow(row + 1);
      case west:
        return position.setCol(col - 1);
      default:
        return new Position(row, col);
    }
  }

  protected void moveVehicle(Vehicle vehicle) {
    if (vehicle.isTicked()) {
      return;
    }

    Cell currentCell = getCurrentCell(vehicle.getCurrentPosition());
    if (vehicle.reachedDestination()) {
      currentCell.unsetVehicle();
      return;
    }

    if (takeDesiredDirection(vehicle)) {
      // Vehicle has taken desired direction. So we are done with it 
      currentCell.unsetVehicle();
    } else {
      // move the vehicle in the direction it is currently heading in. 
      if (takeHeadingDirection(vehicle)) {
        // Vehicle has taken heading direction. So we are done with it 
        currentCell.unsetVehicle();
      } else {
        // Vehicle has not taken heading direction. So we do nothing and set vehicle ticked to true 
        vehicle.setTicked();
      }
    }

  }

  private boolean takeDesiredDirection(Vehicle vehicle) {
    if (vehicle.isTicked()) {
      return false;
    }

    Position currentPosition = vehicle.getCurrentPosition();
    Direction desiredDirection = vehicle.getDesiredDirection();
    if (desiredDirection == null) {
      return false;
    }
    Cell desiredCell = getNextCell(currentPosition, desiredDirection);
    // Check if desired cell allows desired direction 
    if (desiredCell.hasDirection(desiredDirection)) {
      if (desiredCell.hasVehicle()) {
        moveVehicle(desiredCell.getVehicle());
      }
      if (desiredCell.isDrivable(desiredDirection)) {
        desiredCell.setVehicle(vehicle);
        vehicle.setPosition(getNextPosition(currentPosition, desiredDirection));
        vehicle.takeDesiredDirection();
        vehicle.setTicked();
        return true;
      }

    }
    // Check if desired cell allows the current heading direction 
    Direction headingDirection = vehicle.getHeading();
    if (desiredCell.hasDirection(headingDirection)) {
      if (desiredCell.hasVehicle()) {
        moveVehicle(desiredCell.getVehicle());
      }

      if (desiredCell.isDrivable(headingDirection)) {
        desiredCell.setVehicle(vehicle);
        vehicle.setPosition(getNextPosition(currentPosition, desiredDirection));
        vehicle.setTicked();
        return true;
      }

    }
    // Otherwise Vehicle cannot move to the desired cell 
    return false;
  }

  private boolean takeHeadingDirection(Vehicle vehicle) {
    if (vehicle.isTicked()) {
      return false;
    }

    Position currentPosition = vehicle.getCurrentPosition();
    Direction headingDirection = vehicle.getHeading();
    Cell headingCell = getNextCell(currentPosition, headingDirection);
    // sanity check if heading cell exists. E.g. it may be out of bounds but that shouldn't really happen 
    if (headingCell == null) {
      return false;
    }

    if (headingCell.hasDirection(headingDirection)) {
      if (headingCell.hasVehicle()) {
        moveVehicle(headingCell.getVehicle());
      }

      if (headingCell.isDrivable(headingDirection)) {
        headingCell.setVehicle(vehicle);
        vehicle.setPosition(getNextPosition(currentPosition, headingDirection));
        vehicle.setTicked();
        return true;
      }
    }
    // Otherwise Vehicle cannot move to the desired cell 
    return false;

  }

  protected void turnLeft() {
    updateUI();
  }
  protected boolean isWall() {
    return getNextCell(new Position(0, 0), Direction.east) instanceof WallCell;
  }

  protected boolean heading(Direction direction) {
    return false;
  }

  protected void pause() {
    try {
      Thread.sleep(500);
    } catch (InterruptedException e) {
    }
  }

  protected void minipause() {
    try {
      Thread.sleep(50);
    } catch (InterruptedException e) {
    }
  }

  protected void stop() {
    stopped = true;
    updateUI();
  }

  protected void addWall(int row, int col) {
    if (stopped) {
      return;
    }
    world[row][col] = new WallCell();
  }

  protected void addRoad(int row, int col, Direction direction) {
    if (stopped) {
      return;
    }
    if (!(world[row][col] instanceof WallCell)) {
      world[row][col].addDirection(direction);
    } else {
      world[row][col] = new RoadCell(direction);
    }
  }

  protected void addTrafficLight(int row, int col, TrafficLightCell trafficLight) {
    if (stopped) {
      return;
    }
    if (!(world[row][col] instanceof RoadCell)) {
      throw new RuntimeException("Cannot place traffic light on non-road");
    } else {
      world[row][col] = trafficLight;
      trafficLights.add(trafficLight);
    }
  }

  protected void addVehicle(int row, int col, Vehicle vehicle) {
    world[row][col].setVehicle(vehicle);
    this.vehicles.add(vehicle);
  }

  protected boolean isAllowedRow(int row) {
    return row > 0 && row < HEIGHT - 1;
  }

  protected boolean isAllowedCol(int col) {
    return col > 0 && col < WIDTH - 1;
  }

  private void updateUI() {
    for (int i = 0; i < HEIGHT; i++) {
      for (int j = 0; j < WIDTH; j++) {
        Color cell = Color.WHITE;
        Cell worldCell = world[i][j];
        Icon karelIcon = null;

        if (worldCell.hasVehicle()) {
          cell = Color.BLUE;
          Direction direction = worldCell.getVehicle().getHeading();
          switch (direction) {
            case north:
              karelIcon = karelIconNorth;
              break;
            case east:
              karelIcon = karelIconEast;
              break;
            case south:
              karelIcon = karelIconSouth;
              break;
            default:
              karelIcon = karelIconWest;
          }
        }
        cell = worldCell.getColor();
        final VisualCell currentVisual = visuals[i][j];
        final Color cellValue = cell;
        final Icon cellIcon = karelIcon;
        final boolean isStopped = stopped;
        try {
          SwingUtilities.invokeAndWait(new Runnable() {
            @Override
            public void run() {
              if (isStopped) {
                frame.setTitle("Traffic Simulation - STOPPED");
              }
              currentVisual.setBackground(cellValue);
              currentVisual.setIcon(cellIcon);
              currentVisual.setFont(new Font(currentVisual.getFont().getName(), Font.BOLD, 18));
            }
          });
        } catch (Exception e) {
          throw new RuntimeException(e);
        }

      }
    }
  }
}
